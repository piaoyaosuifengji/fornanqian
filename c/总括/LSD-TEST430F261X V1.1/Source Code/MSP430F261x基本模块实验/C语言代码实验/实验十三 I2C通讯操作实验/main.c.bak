/******************************************************************************
** 版权:     杭州利尔达科技有限公司
** 文件名:   IIC
** 工作环境: IAR 4.11B 
** 作者:     谷丰
** 生成日期: 2008.09.10
** 功能: 读取24LC01中0X00存储空间后的数据
         读写方式有
         字节写，随机读，连续读
** 相关文件:
** 修改日志：
*******************************************************************************/
/*******************************************************************************
包含头文件
*******************************************************************************/
#include"msp430x24x.h"
/*******************************************************************************
函数定义
*******************************************************************************/ 
void EEPROM_Write(unsigned char high_Address,unsigned char Word);
void EEPROM_radom(unsigned char high_Address);
void EEPROM_read(void);
void Delay(void);
/*******************************************************************************
全局变量的定义
*******************************************************************************/ 
unsigned char RXData;
unsigned char count;
/*************************************************************************
** 函数名称：初始化函数
** 工作环境: IAR 4.11B 
** 作者:     谷丰
** 生成日期: 2008.09.10
** 功能:初始化I2C接口
        传输方式设置，主从设置，波特率设置
** 相关文件:
** 修改日志：
*************************************************************************/
void Init_iic(void)
{
  if (CALBC1_1MHZ ==0xFF || CALDCO_1MHZ == 0xFF)                                     
  {  
    while(1);                               // If calibration constants erased
                                            // do not load, trap CPU!!
  }    
  BCSCTL1 = CALBC1_1MHZ;                    // 设置DCO参数
  DCOCTL = CALDCO_1MHZ;
  P4DIR |= BIT1;
  P4OUT &= ~BIT1;
  P3SEL |= BIT1 + BIT2; 
  P5SEL |= BIT1 + BIT2;
  P4DIR |= BIT5;
  P4OUT &= ~BIT5;                           // 开启24C01电源
  UCB1CTL1 |= UCSWRST;                      // 复位IIC
  UCB1CTL0 = UCMST + UCMODE_3 + UCSYNC;     // IIC主机同步模式
  UCB1CTL1 |= UCSSEL_2;                     // 时钟选择
  UCB1BR0 = 10;                             // fSCL = SMCLK/12 = ~100kHz
  UCB1BR1 = 0;
  UCB1I2CSA = 0x51;                         // 从机地址为0X51
  UCB1CTL1 &= ~UCSWRST;                     // Clear SW reset, resume operation
  UC1IE |= UCB1RXIE;                         // 使能接收中断
  _EINT();
}
/*************************************************************************
** 函数名称：字节写函数
** 工作环境: IAR 4.11B 
** 作者:     谷丰
** 生成日期: 2008.09.10
** 功能:向相关的存储单元写入数据
** 相关文件:
** 修改日志：
*************************************************************************/
void EEPROM_Write(unsigned char high_Address,unsigned char Word)
{
  while (UCB1CTL1 & UCTXSTP);               // 确定总线空闲
  UCB1CTL1 |= UCTXSTT + UCTR;               // 发送起始位，确定为发送模式
  UCB1TXBUF = high_Address;                 // 发送高位地址
  while((UC1IFG & UCB1TXIFG)==0);            // 判断是否发送完毕
  UCB1TXBUF = Word;                         // 发送数据
  while((UC1IFG & UCB1TXIFG)==0);            // 判断是否发送完毕
  UCB1CTL1 |= UCTXSTP;                      // 发送停止位
  while((UCB1CTL1 & UCTXSTP)==1);           // 判断停止位是否发送完毕
}
/*************************************************************************
** 函数名称：字节读函数
** 工作环境: IAR 4.11B 
** 作者:     谷丰
** 生成日期: 2008.09.10
** 功能:     随机读发送设置
** 相关文件:
** 修改日志：
*************************************************************************/
void EEPROM_radom(unsigned char high_Address)
{
  while (UCB1CTL1 & UCTXSTP);               // Ensure stop condition got sent
  UCB1CTL1 |= UCTXSTT + UCTR;               // 发送起始位，确定为写 
  UCB1TXBUF = high_Address;                 // 发送地址位高位
  while((UC1IFG & UCB1TXIFG)==0);            // 判断是否发送完毕 
  UCB1CTL1 &= ~UCTR;                        // 确定为接收
  while (UCB1CTL1 & UCTXSTP);               // 判断总线是否被释放
  UCB1CTL1 |=UCTXSTT;                       // 重新发送起始位
  while((UCB1CTL1 & UCTXSTT)==1);           // 判断起始位是否发送成功
//for(unsigned char i=0x0;i<0x2f;i++);      // 延时确定数据已经被发送出去 
  UCB1CTL1 |=UCTXSTP + UCTXNACK;            // 发送停止位和NACK位 
}
/*************************************************************************
** 函数名称：字节读函数
** 工作环境: IAR 4.11B 
** 作者:     谷丰
** 生成日期: 2008.09.10
** 功能:     连续读发送设置
** 相关文件:
** 修改日志：
*************************************************************************/
void EEPROM_read()
{
  UCB1CTL1 &= ~UCTR;                       // 确定为读
  while (UCB1CTL1 & UCTXSTP);              // 总线是否空闲
  UCB1CTL1 |= UCTXSTT;                     // 发送开始位
}
/*************************************************************************
** 函数名称：主函数
** 工作环境: IAR 4.11B 
** 作者:     谷丰
** 生成日期: 2008.09.10
** 相关文件:
** 修改日志：
*************************************************************************/
void main(void)
{
  WDTCTL = WDTPW + WDTHOLD;
  P1DIR |= BIT0 ;
  Init_iic();                             
  while(1)
  {
    P1OUT ^= BIT0 ;
    EEPROM_Write(00,0xf0);                   // 字节写函数
    Delay();
    EEPROM_radom(0X00);                      // 随机读函数
    Delay();
    EEPROM_read();                           // 连续读取从00开始的数据
  }
}
/*************************************************************************
** 函数名称：延时函数
** 工作环境: IAR 4.11B 
** 作者:     谷丰
** 生成日期: 2008.09.10
** 功能:STOP信号和START信号之间延时 5MS
** 相关文件:
** 修改日志：
*************************************************************************/
void Delay()
{
  for(unsigned char i=0;i<0xff;i++);
  for(unsigned char i=0;i<0xff;i++);
  for(unsigned char i=0;i<0xff;i++);
  for(unsigned char i=0;i<0xff;i++);
  for(unsigned char i=0;i<0xff;i++);
}
/*************************************************************************
** 函数名称：接收中断函数
** 工作环境: IAR 4.11B 
** 作者:     谷丰
** 生成日期: 2008.09.10
** 功能:    存取接收的数据
** 相关文件:
** 修改日志：
*************************************************************************/
#pragma vector = USCIAB1TX_VECTOR
__interrupt void USCIAB3_ISR(void)
{
  if(UC1IFG  & UCB1RXIFG)                     // 接收中断
  {
   count++;
   RXData = UCB1RXBUF; 
  }
}






