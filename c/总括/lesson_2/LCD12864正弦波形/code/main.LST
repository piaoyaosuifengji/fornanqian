C51 COMPILER V8.05a   MAIN                                                                 04/14/2013 16:59:28 PAGE 1   


C51 COMPILER V8.05a, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*****http:hi.baidu.com/echoas********
   2          程序：MCS-51驱动LCD12864液晶
   3          内容：LCD12864显示正弦曲线
   4          编译器：keil uVision3
   5          开发板：Proteus仿真图
   6          ******http:hi.baidu.com/echoas*********/ 
   7          #include <AT89X52.h>
   8          #include <intrins.h>
   9          #include<math.h>
  10          #include"ZB.h"
  11          #define uchar unsigned char
  12          #define uint  unsigned int
  13          
  14          #define LCD_databus P0 //LCD12864的8位数据口
  15          
  16          sbit RS=P2^2;   //RS为0---命令；1----数据 
  17          sbit RW=P2^1;   //RW为1---写；0---读 
  18          sbit EN=P2^0;   //使能端 
  19          sbit CS1=P2^4;  //片选1低电平有效，控制左半屏 
  20          sbit CS2=P2^3;  //片选1低电平有效，控制右半屏 
  21          
  22          
  23          void Read_busy()//读“忙”函数-----数据线的最高位DB71则busy             
  24          {
  25   1              P0=0x00;
  26   1              RS=0;  
  27   1              RW=1; 
  28   1              EN=1;
  29   1              while(P0 & 0x80);
  30   1              EN=0;
  31   1      }
  32          
  33          void write_LCD_command(uchar value)     //写命令函数 
  34          {
  35   1         Read_busy();                                         //对LCD的每次读写都要读忙 
  36   1         RS=0;                                                        //选择命令 
  37   1         RW=0;                                                        //读操作 
  38   1         LCD_databus=value;
  39   1         EN=1;                                                        //EN由1----0锁存有效数据 
  40   1         _nop_();
  41   1         _nop_(); 
  42   1         EN=0;
  43   1      }
  44          
  45          void write_LCD_data(uchar value)//写数据函数    
  46          {
  47   1         Read_busy();
  48   1         RS=1;                                                //选择数据 
  49   1         RW=0;        
  50   1         LCD_databus=value;
  51   1         EN=1;                                                //EN由1----0锁存有效数据 
  52   1         _nop_();             
  53   1         _nop_();
  54   1         EN=0;
  55   1      }
C51 COMPILER V8.05a   MAIN                                                                 04/14/2013 16:59:28 PAGE 2   

  56          
  57          uchar Read_LCD(void)                    //读数据函数 
  58          {
  59   1              uchar value;
  60   1              Read_busy();
  61   1              LCD_databus=0xFF;                       //先进行一次空读操作 
  62   1              RS=1;
  63   1              RW=1;
  64   1              EN=1;
  65   1              _nop_();
  66   1              _nop_();
  67   1              EN=0;
  68   1              
  69   1              LCD_databus=0xFF;                       //读取真正的数据 
  70   1              RS=1;
  71   1              RW=1;
  72   1              EN=1;
  73   1              value=LCD_databus;
  74   1              _nop_();
  75   1              _nop_();
  76   1              EN=0;
  77   1              
  78   1              return value; 
  79   1      }
  80          
  81          void Set_page(uchar page)               //设置“页”LCD12864共8页，一页是8行点阵点      
  82          {
  83   1        page=0xb8|page;                               //页的首地址为0xB8
  84   1        write_LCD_command(page);
  85   1      }
  86          
  87          void Set_line(uchar startline)  //设置显示的起始行         
  88          {
  89   1        startline=0xC0|startline;     //起始行地址为0xC0 
  90   1        write_LCD_command(startline); //设置从哪行开始：共0--63;一般从0 行开始显示
  91   1      }
  92          
  93          void Set_column(uchar column)   //设置显示的列  
  94          {
  95   1        column=column &0x3f;                  //列的最大值为64
  96   1        column= 0x40|column;                  //列的首地址为0x40 
  97   1        write_LCD_command(column);    //规定显示的列的位置 
  98   1      }
  99          
 100          void SetOnOff(uchar onoff)              //显示开关函数：0x3E是关显示，0x3F是开显示   
 101          {
 102   1              onoff=0x3e|onoff;                       //onoff:1---开显示；0---关显示
 103   1              write_LCD_command(onoff);
 104   1      }
 105          
 106          void SelectScreen(uchar screen) //选择屏幕 
 107          {                                                
 108   1         switch(screen)
 109   1         { 
 110   2               case 0: CS1=0;CS2=0;break; //全屏     
 111   2           case 1: CS1=0;CS2=1;break;//左半屏        
 112   2           case 2: CS1=1;CS2=0;break;//右半屏       
 113   2           default:break; 
 114   2         }
 115   1      }
 116          
 117          void ClearScreen(uchar screen)  //清屏函数  
C51 COMPILER V8.05a   MAIN                                                                 04/14/2013 16:59:28 PAGE 3   

 118          {       
 119   1           uchar i,j;
 120   1           SelectScreen(screen);              //0--全屏；1---左半屏；2---右半屏 
 121   1               for(i=0;i<8;i++)                       //控制页数0-7，共8页
 122   1               {
 123   2              Set_page(i);
 124   2                      Set_column(0);
 125   2              for(j=0;j<64;j++)          //控制列数0-63，共64列
 126   2                      {
 127   3                write_LCD_data(0x00); //写入0，地址指针自加1 
 128   3              }
 129   2           }                                   
 130   1      }
 131          
 132          void InitLCD()                                  //LCD的初始化  
 133          { 
 134   1              SetOnOff(1);                            //开显示
 135   1              SelectScreen(0);
 136   1              ClearScreen(0);                         //清屏
 137   1              Set_line(0);                            //开始行:0
 138   1      }
 139          /************************************************
 140          LCD12864任意坐标位置打点函数：坐标
 141          左上方(0,0)--------------------------(127,0)-
 142          -                                                                                       -
 143          -                       坐标系                                                  -
 144          -                                                                                       -
 145          -                                                                                       -       
 146          (0,63)------------------------右下方(127,63)-   
 147          原理：确定要打点的具体位置(坐标)，然后读取出LCD中
 148          的数据，经过数据处理后再送入LCD中进行显示。 
 149          ************************************************/ 
 150          void Draw_dots(uchar x,uchar y,uchar color)
 151          {
 152   1              uchar x_byte;
 153   1              uchar x_bit; 
 154   1              uchar Temp_data;                //暂时存放从LCD读出的数据 
 155   1              x_byte=(y>>3);                  //计算出该点属于哪个字节 
 156   1              x_bit=y-(x_byte<<3);    //属于字节的哪一位 
 157   1      
 158   1              
 159   1              if(x>63)                                //x>63则显示在右半屏 
 160   1              {
 161   2                      SelectScreen(2);
 162   2                      x=x-64;
 163   2              }
 164   1              else                                    //显示在左半屏 
 165   1              {
 166   2                      SelectScreen(1); 
 167   2              }
 168   1              Set_page(x_byte);               //设置行地址 
 169   1              Set_column(x);                  //设置列地址
 170   1              Temp_data=Read_LCD();   //先读出没打点前LCD中的数据 
 171   1              switch(color)
 172   1              {
 173   2                      case 0x01 : Temp_data &= ~(1<<x_bit);break;     //擦除
 174   2                      case 0x02 : Temp_data ^= (1<<x_bit); break;     //反白 
 175   2                      case 0x03 : Temp_data |= (1<<x_bit); break;     //画点 
 176   2                      default : break;
 177   2              } 
 178   1              
 179   1              Set_page(x_byte);
C51 COMPILER V8.05a   MAIN                                                                 04/14/2013 16:59:28 PAGE 4   

 180   1              Set_column(x);
 181   1              write_LCD_data(Temp_data);      //将处理后的数据送到LCD中显示 
 182   1              
 183   1      }
 184          /*********************************************************
 185          函数：显示汉字----点阵大小为16*16 
 186          要显示一个完整的汉字，要分两页写入数据来完成，一页是8行点阵
 187          的大小，先写上半部分，再写下半部分！可通过Proteus联调看出！ 
 188          *********************************************************/ 
 189          void Display_HZ(uchar ss,uchar page,uchar column,uchar *p)
 190          {
 191   1              uchar i;
 192   1              SelectScreen(ss);
 193   1              Set_page(page);                                 //写上半页
 194   1              Set_column(column*16);                  //控制列
 195   1              for(i=0;i<16;i++)                               //控制16列的数据输出
 196   1              {
 197   2                      write_LCD_data(p[i]);           //汉字的上半部分 
 198   2              }
 199   1              Set_page(page+1);                               //写下半页
 200   1              Set_column(column*16);                  //控制列
 201   1          for(i=0;i<16;i++)                           //控制16列的数据输出
 202   1              {
 203   2                      write_LCD_data(p[i+16]);        //汉字的下半部分 
 204   2              }
 205   1      } 
 206          
 207          void Display_picture(uchar a[][64])//显示图形--坐标 
 208          {
 209   1              uchar i,j;
 210   1              
 211   1              for(j=0;j<6;j++)
 212   1              {       
 213   2                      SelectScreen(1);
 214   2                      Set_page(j+2);                          //从第三页开始显示 
 215   2                      Set_column(0);
 216   2                      for(i=0;i<64;i++)
 217   2                      {
 218   3                              write_LCD_data(a[2*j][i]);//每隔一行取一次数组中的数据
 219   3                      }
 220   2                      SelectScreen(2);
 221   2                      Set_page(j+2);
 222   2                      Set_column(0);
 223   2                      for(i=0;i<64;i++)
 224   2                      {
 225   3                              write_LCD_data(a[2*j+1][i]);//每隔一行取一次数组中的数据
 226   3                      }       
 227   2              }       
 228   1      }
 229          void main()
 230          {  
 231   1              uchar x,y;
 232   1              InitLCD();                      //初始12864  
 233   1              ClearScreen(0);         //清屏
 234   1              Set_line(0);            //显示开始行
 235   1      
 236   1              Display_HZ(1,0,0,da);           //大
 237   1              Display_HZ(1,0,1,hai);          //海
 238   1              Display_HZ(1,0,2,xiang);        //橡
 239   1              Display_HZ(1,0,3,shu);          //树
 240   1              Display_HZ(2,0,0,bai);          //百
 241   1              Display_HZ(2,0,1,du);           //度
C51 COMPILER V8.05a   MAIN                                                                 04/14/2013 16:59:28 PAGE 5   

 242   1              Display_HZ(2,0,2,kong);         //空
 243   1              Display_HZ(2,0,3,jian);         //间
 244   1              Display_picture(BMP);           //坐标图
 245   1              for(x=12;x<128;x++)                     //正弦曲线
 246   1              {
 247   2                      y=35-18*sin((x-12)*3.14/16);
 248   2                      Draw_dots(x,y,2);
 249   2              }
 250   1                      
 251   1              while(1);
 252   1      }
 253          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    768    ----
   CONSTANT SIZE    =   1024    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
